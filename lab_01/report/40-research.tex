\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров алгоритмов по пиковой памяти и процессорному времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Ubuntu 22.04.1 \cite{ubuntu} Linux x86\_64.
	\item Память: 8 ГБ.
	\item Процессор: AMD® Ryzen 5 3500u.
\end{itemize}

Во время тестирования устройство было подключено к сети электропитания, нагружено приложениями окружения и самой  системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины слов проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова.При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки. Тестовые пакеты создавались до начала замера времени.

Результаты замеров приведены в таблице \ref{tab:time} (время в микросекундах).

\begin{table}[h]
	\begin{center}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{\label{tab:time}Результаты замеров времени (в микросекундах).}
			\begin{tabular}{|l|l|l|l|l|}
				
				\hline
				Длина&Л.(не рек.)&Д.-Л.(не рек.)&Д.-Л.(рек.)&Д.-Л.(рек.кеш.)\\
				\hline
				0 & 1 & 2 & 0 & 0 \\
				\hline
				1 & 3 & 4 & 1 & 2 \\
				\hline
				3 & 11 & 11 & 27 & 16 \\
				\hline
				5 & 20 & 23 & 685 & 38 \\
				\hline
				10 & 64 & 79 & 3296002 & 144 \\
				\hline
				25 & 359 & 477 & - & 946 \\
				\hline
			\end{tabular}
	\end{center}
\end{table}

 
\section{Использование памяти}

Алгоритмы тестировались при помощи функции get\_traced\_memory() из библиотеки tracemalloc языка Python, которая возвращает пиковый количество памяти, использованное процессором, на определенном этапе выполнения программы.

При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки. Тестовые пакеты создавались до начала замера памяти.

Результаты замеров приведены в таблице \ref{tab:time} (в байтах).

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tab:memory}Результаты замеров памяти (в байтах).}
		
		\begin{tabular}{|l|l|l|l|l|}
			
			\hline
			Длина&Л.(не рек.)&Д.-Л.(не рек.)&Д.-Л.(рек.)&Д.-Л.(рек.кеш.)\\
			\hline
			0 & 472 & 472 & 0 & 0 \\
			\hline
			1 & 536 & 536 & 48 & 544 \\
			\hline
			3 & 600 & 600 & 48 & 2856 \\
			\hline
			5 & 872 & 872 & 411 & 3672 \\
			\hline
			10 & 1960 & 1960 & 48 & 14096 \\
			\hline
			25 & 7504 & 7336 & - & 64840 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section*{Вывод}

В результате замеров можно сделать вывод о том, что чем меньше длина строки, тем эффективнее по памяти и времени работает алгоритм вычисления редакторского расстояния. Самым эффективным по памяти является рекурсивный алгоритм Дамерау­ -- Левенштейна без кеширования, самым неэффективным рекурсивный алгоритм Дамерау­ -- Левенштейна с кешированием. Согласно результатам замеров процессорного времени самым быстрым оказался нерекурсивный алгоритм Дамерау -- Левенштейна, самым медленным - рекурсивный алгоритм Дамерау -- Левенштейна без кеширования.
